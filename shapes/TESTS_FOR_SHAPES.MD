 # ТЕСТЫ ДЛЯ ЗАДАНИЯ С ФИГУРАМИ

 - [x] 1 тест, проверка функций на примере квадрата и вашей фигуры :tada::

> следующие 5 методов (функций класса) должны быть определены в родительском классе как чисто-виртуальные:

### getArea() для квадрата со стороной: 6
``` cpp
Point a = { 0.0, 0.0 };
double length = 6.0;

Square square{a, length}; //конечно, при создании нового экземпляра класса своей фигуры, вы указываете свои аргументы.

std::cout << "area: " << square.getArea() << '\n';
```
код выведет:
```
area: 36.0
```
> Для вашей фигуры аналогично, основываясь на ее параметрах должно определить ее площадь (хардкод без вычислений строго запрещен)

### getFrameRectangle() для того же квадрата с координатами для левой-нижней точки: x = 0, y = 0 и длиной: 6
getFrameRectangle() не должен принимать параметров, т.к они ему не нужны :з
``` cpp
Point a = { 0.0, 0.0 };
double length = 6.0;

Square square{a, length};

square.getFrameRectangle(); //если метод ничего не возращает, тип: void.
//или
std::cout << square.getFrameRectangle(); // если метод возвращает объект, типа: FrameRectangle.
//или
FrameRectangle::getFrameRectangle(square); //если это статический метод, типа: void.
//или
std::cout << FrameRectangle::getFrameRectangle(square) // если статический метод возвращает объект, типа: FrameRectangle.
```
код выведет:
```
x = 0.0; y = 0.0 x = 6.0; y = 6.0
```
> Для вашей фигуры аналогично

### move(double k) принимает 1 аргумент: значение для перемещения центра фигуры
или
### move(double k_x, double k_y) принимает 2 аргумента: значения для x и y для перемещения центра фигуры на x и y соответственно.
``` cpp
Point a = { 0.0, 0.0 };
double length = 6.0;

Square square{a, length};
// здесь центр фигуры находится в точке 3.0
square.move(5.0);
// здесь центр фигуры находится в точке 8.0
std::cout << "new centre: " << square.getCentre() << std::endl;
```
код выведет:
```
new centre: x = 8.0; y = 8.0 //оформление вывода на вкус и цвет, главное понять, что x и y = 8.0
```
### scale(double k) принимает 1 аргумент: значение изотнопного масштабирования фигуры относительно её центра

``` cpp
//на основе новых данных из прошлой функции

square.scale(2.0);

square.getFrameRectangle(); // для проверки новых границ FrameRectangle
std::cout << "\nnew centre: " << square.getCentre() << std::endl;
```
код выведет:
```
x = 2.0; y = 2.0 x = 14.0; y = 14.0
new centre: x = 8.0; y = 8.0
```
### clone() по т.з. clone является методом класса, а значит аргументы ему не нужны
``` cpp
//на основе новых данных из прошлой функции

Square square_clone = square.clone();

square_clone.getFrameRectangle(); // для проверки границ 

square_clone.move(-2.0); // двигаем копию нашей фигурки

square_clone.getInfo(); // функция, которая просто выдает в общем виде все данные об экземпляре класса shape.

// так же, на всякий случай, проверим, что с оригинальной фигурой ничего не случилось.

square.getInfo(); // Наименование фигуры, площадь, и корды левый-низ, правый-верх.
```
должно выйти что-то такое:
```
x = 2; y = 2 x = 14; y = 14

SQUARE 144 x = 0; y = 0 x = 12; y = 12 // это клон, сдвинутый на -2.0 позиции

SQUARE 144 x = 2; y = 2 x = 14; y = 14 // это оргиниальный квадрат
```
### getName() не принимает аргументов, т.к является методом класса
``` cpp
//на основе последних данных

square.getName();
square_clone.getName();
```
код выведет:
```
SQUARE
SQUARE
```
> для второй вашей фигуры тестирование сходится

